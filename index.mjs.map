{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2024 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport nextGraphemeClusterBreak from '@stdlib/string-next-grapheme-cluster-break';\nimport CircularBuffer from '@stdlib/dstructs-circular-buffer';\nimport zeros from '@stdlib/array-base-zeros';\n\n\n// MAIN //\n\n/**\n* Returns the last `n` grapheme clusters (i.e., user-perceived characters) of a string.\n*\n* @param {string} str - input string\n* @param {NonNegativeInteger} n - number of grapheme clusters to return\n* @returns {string} output string\n*\n* @example\n* var out = last( 'Hello World', 1 );\n* // returns 'd'\n*\n* @example\n* var out = last( 'Evening', 3 );\n* // returns 'ing'\n*\n* @example\n* var out = last( 'JavaScript', 6 );\n* // returns 'Script'\n*\n* @example\n* var out = last( 'ÂÖ≠‰π¶/ÂÖ≠Êõ∏', 1 );\n* // returns 'Êõ∏'\n*\n* @example\n* var out = last( 'üê∂üêÆüê∑üê∞üê∏', 2 );\n* // returns 'üê∞üê∏'\n*/\nfunction last( str, n ) {\n\tvar count;\n\tvar cbuf;\n\tvar buf;\n\tvar i;\n\n\tif ( n === 0 || str === '' ) {\n\t\treturn '';\n\t}\n\t// Resolve the first cluster break:\n\ti = nextGraphemeClusterBreak( str, 0 );\n\n\t// If we received a sentinel value, return the input string, as there are no more cluster breaks to iterate over...\n\tif ( i === -1 ) {\n\t\treturn str;\n\t}\n\t// Initialize a buffer for keeping track of cluster break indices:\n\tbuf = zeros( n );\n\n\t// Wrap the buffer to create a circular buffer serving as a FIFO stack where we can keep at most `n` indices as we iterate from left-to-right:\n\tcbuf = new CircularBuffer( buf );\n\n\t// Add the first character index:\n\tcbuf.push( 0 );\n\n\t// Add the index of the first grapheme cluster break to our buffer:\n\tcbuf.push( i );\n\n\t// Slide a window over the string from left-to-right...\n\tcount = 0;\n\twhile ( true ) {\n\t\tcount += 1;\n\t\ti = nextGraphemeClusterBreak( str, i );\n\t\tif ( i === -1 ) {\n\t\t\tbreak;\n\t\t}\n\t\tcbuf.push( i );\n\t}\n\t// Resolve the leftmost index:\n\ti = buf[ (count+1)%n ]; // count+1 as count%n corresponds to the index of the \"newest\" element in the circular buffer and count+1 is the next element to replace (i.e., the \"oldest\" index)\n\n\t// Return the last `n` grapheme clusters:\n\treturn str.substring( i );\n}\n\n\n// EXPORTS //\n\nexport default last;\n"],"names":["last","str","n","count","cbuf","buf","i","nextGraphemeClusterBreak","zeros","CircularBuffer","push","substring"],"mappings":";;oSAwDA,SAASA,EAAMC,EAAKC,GACnB,IAAIC,EACAC,EACAC,EACAC,EAEJ,GAAW,IAANJ,GAAmB,KAARD,EACf,MAAO,GAMR,IAAY,KAHZK,EAAIC,EAA0BN,EAAK,IAIlC,OAAOA,EAgBR,IAbAI,EAAMG,EAAON,IAGbE,EAAO,IAAIK,EAAgBJ,IAGtBK,KAAM,GAGXN,EAAKM,KAAMJ,GAGXH,EAAQ,EAEPA,GAAS,GAEG,KADZG,EAAIC,EAA0BN,EAAKK,KAInCF,EAAKM,KAAMJ,GAMZ,OAHAA,EAAID,GAAMF,EAAM,GAAGD,GAGZD,EAAIU,UAAWL,EACvB"}